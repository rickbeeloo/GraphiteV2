        - 
        - 
        - const LIBSAIS = "libsais-2.7.1/libsais.so.2"
        - 
        - function concat_with_seperator(vectors::Vector{Vector{Int32}})
        -     # Probably a cleaner way to do this :) Like using map 
        -     # to flip the node ids in slices and copying the slices to the output
        0     total_size = sum(map(length, vectors))
        0     concat_arr = zeros(Int32, total_size + length(vectors)) 
        0     vect_id = -1 * length(vectors) # to have it decending for sorting
        -     # Concat with seperator + store sign in most significant bit
        -     i = 1
        0     @inbounds for v in vectors
        0         for node_id in v 
        0             concat_arr[i] = node_id
        0             i +=1
        0         end 
        0         concat_arr[i] = vect_id 
        0         vect_id +=1
        0         i +=1
        0     end
        0     return concat_arr
        - end
        - 
        - function create_suffix_array(in_vector::Vector{Int32}, free_space::Int32)
        0     out_vector = zeros(Int32, length(in_vector) + free_space)
        0     d = Dict(Iterators.map(reverse,pairs(sort(unique(in_vector)))))
        0     in_vector = Int32.(get.(Ref(d), in_vector, 0))
        0     n = length(in_vector)
        0     k = maximum(in_vector) +1 
        0     @ccall LIBSAIS.libsais_int(in_vector::Ptr{Int32}, out_vector::Ptr{Int32}, n::Int32, k::Int32, free_space::Int32)::Int32
        0     out_vector .+= 1
        0     return out_vector
        - end
        - 
        - function create_k_suffix_array(vectors::Vector{Vector{Int32}}, free_space::Int32)
        -     concat_array = concat_with_seperator(vectors)
        -     suffix_array = create_suffix_array(concat_array, free_space)
        -     return concat_array, suffix_array
        - end
        - 
        - function build_lcp(sa::Vector{Int32}, V::Vector{Int32}, base::Integer=1)
        -     T = eltype(sa)
        0     pos = sa .+ T(1-base)
        0     n = length(pos)
        0     lcparr = similar(pos)
        0     rank = invperm(pos)
        -     h = 0
        0     for i in 1:n
        0         if rank[i] == 1
        -             continue
        -         end
        0         j = pos[rank[i]-1]
        0         maxh = n - max(i, j)
        0         while h <= maxh && V[i+h] == V[j+h]
        0             h += 1
        -         end
        0         lcparr[rank[i]] = h
        0         h = max(h-1, 0)
        0     end
        0     lcparr[1] = 0
        0     return lcparr
        - end
        - 
        - function locate_insert_point(sa::Vector{Int32}, concat_arr::Vector{Int32}, ref::AbstractVector{Int32})
        -     low = 1 
        0     high = length(sa)
        0     suffix_arr_len = length(sa)
        0     while low <= high 
        0         mid = low + ((high - low) >>> 0x01) 
        0         suffix_start = sa[mid]
        0         suffix = view(concat_arr, suffix_start:suffix_arr_len)
        0         if ref < suffix 
        0             high = mid - 1
        0         elseif ref > suffix
        0             low = mid + 1
        -         else 
        0             return Int32(mid)  # then they should be equal, exact match
        -         end
        0     end
        0     return Int32(low)
        - end
        - 
        - function inverse_perm_sa(sa::Vector{Int32})
        -     inv_sa_perm = similar(sa)
        -     for i in 1:length(sa)
        -         inv_sa_perm[sa[i]] = i
        -     end
        -     return inv_sa_perm
        - end
